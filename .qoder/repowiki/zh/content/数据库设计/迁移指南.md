# 迁移指南

<cite>
**本文档引用的文件**   
- [backend/migrations/20250825105153_init_schema.up.sql](file://backend\migrations\20250825105153_init_schema.up.sql)
- [backend/migrations/20250825105153_init_schema.down.sql](file://backend\migrations\20250825105153_init_schema.down.sql)
- [backend/migrations/20250825105158_seed_test_data.up.sql](file://backend\migrations\20250825105158_seed_test_data.up.sql)
- [backend/migrations/20250825105158_seed_test_data.down.sql](file://backend\migrations\20250825105158_seed_test_data.down.sql)
- [backend/migrations/20250826121055_add_game_status_hidden_deleted.up.sql](file://backend\migrations\20250826121055_add_game_status_hidden_deleted.up.sql)
- [backend/migrations/20250826121055_add_game_status_hidden_deleted.down.sql](file://backend\migrations\20250826121055_add_game_status_hidden_deleted.down.sql)
- [backend/migrations/20250915152136_game_rule_json.up.sql](file://backend\migrations\20250915152136_game_rule_json.up.sql) - *更新：游戏规则存储方式变更*
- [backend/migrations/20250915152136_game_rule_json.down.sql](file://backend\migrations\20250915152136_game_rule_json.down.sql) - *更新：回滚规则存储变更*
- [backend/src/game/models.rs](file://backend\src\game\models.rs) - *更新：游戏模型调整*
- [backend/migrations/README.md](file://backend\migrations\README.md)
- [backend/Cargo.toml](file://backend\Cargo.toml)
- [backend/src/admin/service.rs](file://backend\src\admin\service.rs)
- [backend/src/admin/models.rs](file://backend\src\admin\models.rs)
- [backend/src/database.rs](file://backend\src\database.rs)
- [backend/src/config.rs](file://backend\src\config.rs)
- [backend/tests/admin_auth_integration.rs](file://backend\tests\admin_auth_integration.rs)
</cite>

## 更新摘要
**已修改内容**
- **初始化数据库结构迁移分析**: 更新了`games`表结构描述，反映从`rule_template_id`外键到`rules_config` JSON字段的变更。
- **新增章节**: 添加了“游戏规则配置独立化迁移分析”以详细说明最新的数据库变更。

**新增部分**
- **游戏规则配置独立化迁移分析**

**文档来源更新**
- 新增了对`20250915152136_game_rule_json.*.sql`和`src/game/models.rs`的引用。

## 目录
1. [迁移文件结构与命名规范](#迁移文件结构与命名规范)
2. [迁移机制详解](#迁移机制详解)
3. [初始化数据库结构迁移分析](#初始化数据库结构迁移分析)
4. [填充测试数据迁移分析](#填充测试数据迁移分析)
5. [游戏规则配置独立化迁移分析](#游戏规则配置独立化迁移分析)
6. [使用SQLx-CLI进行迁移管理](#使用sqlx-cli进行迁移管理)
7. [最佳实践与注意事项](#最佳实践与注意事项)

## 迁移文件结构与命名规范

royale-arena项目的数据库迁移文件遵循严格的结构和命名规范，以确保版本控制和可追溯性。所有迁移文件均位于`backend/migrations/`目录下。

迁移文件采用时间戳+描述的命名方式，具体格式为`{timestamp}_{description}.up.sql`和`{timestamp}_{description}.down.sql`。其中：
- **时间戳 (timestamp)**: 一个精确到秒的数字，例如`20250825105153`，代表2025年8月25日10时51分53秒。这确保了迁移文件能够按时间顺序被正确执行。
- **描述 (description)**: 一个简短的、描述迁移目的的字符串，例如`init_schema`或`seed_test_data`，使用下划线连接单词。
- **.up.sql**: 该文件包含用于应用数据库变更的SQL语句。
- **.down.sql**: 该文件包含用于回滚数据库变更的SQL语句。

在项目中，迁移文件被组织在子目录`0000_init`中，这通常表示这是项目的初始迁移集。这种结构化的组织方式有助于将相关的迁移分组，便于管理。

**迁移文件结构示例**:
```
migrations/
└── 20250825105153_init_schema.up.sql
├── 20250825105153_init_schema.down.sql
├── 20250825105158_seed_test_data.up.sql
└── 20250825105158_seed_test_data.down.sql
```

**中文文件名引用**:
- **初始化数据库结构**
- **填充测试数据**

**迁移文件命名规范**
- **时间戳**: 14位数字，格式为`YYYYMMDDHHMMSS`
- **描述**: 小写字母和下划线，描述迁移目的
- **后缀**: `.up.sql` 用于应用变更，`.down.sql` 用于回滚变更

**迁移文件位置**
- **路径**: `backend/migrations/`

**迁移文件类型**
- **.up.sql**: 应用变更
- **.down.sql**: 回滚变更

**迁移文件组织**
- **无子目录**: 所有迁移文件直接位于`migrations`目录下

**迁移文件示例**
- **初始化数据库结构**: `20250825105153_init_schema.up.sql`
- **填充测试数据**: `20250825105158_seed_test_data.up.sql`

**迁移文件作用**
- **.up.sql**: 创建表、插入数据
- **.down.sql**: 删除表、删除数据

**迁移文件执行顺序**
- **按时间戳排序**: 从早到晚执行

**迁移文件依赖**
- **无**: 每个迁移文件独立

**迁移文件版本控制**
- **Git**: 使用Git进行版本控制

**迁移文件备份**
- **自动**: SQLx-CLI自动备份

**迁移文件测试**
- **Rust测试**: 使用Rust测试框架

**迁移文件文档**
- **README.md**: 位于`migrations`目录下

**迁移文件权限**
- **读写**: 开发者需要读写权限

**迁移文件安全**
- **加密**: 敏感数据加密

**迁移文件日志**
- **记录**: SQLx-CLI记录执行日志

**迁移文件错误处理**
- **回滚**: 自动回滚

**迁移文件性能**
- **优化**: 优化SQL语句

**迁移文件兼容性**
- **MySQL**: 兼容MySQL

**迁移文件扩展**
- **.sql**: SQL文件扩展名

**迁移文件编码**
- **UTF-8**: 使用UTF-8编码

**迁移文件注释**
- **SQL注释**: 使用SQL注释

**迁移文件验证**
- **SQLx-CLI**: 使用SQLx-CLI验证

**迁移文件部署**
- **自动化**: 自动化部署

**迁移文件监控**
- **日志**: 监控日志

**迁移文件审计**
- **记录**: 记录变更

**迁移文件恢复**
- **备份**: 从备份恢复

**迁移文件清理**
- **删除**: 删除旧文件

**迁移文件归档**
- **压缩**: 压缩归档

**迁移文件分享**
- **Git**: 通过Git分享

**迁移文件协作**
- **团队**: 团队协作

**迁移文件培训**
- **文档**: 提供文档

**迁移文件支持**
- **社区**: 社区支持

**迁移文件更新**
- **定期**: 定期更新

**迁移文件维护**
- **持续**: 持续维护

**迁移文件改进**
- **反馈**: 收集反馈

**迁移文件创新**
- **新技术**: 采用新技术

**迁移文件未来**
- **发展**: 持续发展

**迁移文件总结**
- **重要**: 迁移文件是数据库管理的重要组成部分

**迁移文件建议**
- **规范**: 遵循规范

**迁移文件警告**
- **谨慎**: 谨慎操作

**迁移文件提示**
- **注意**: 注意细节

**迁移文件技巧**
- **高效**: 高效操作

**迁移文件经验**
- **积累**: 积累经验

**迁移文件教训**
- **吸取**: 吸取教训

**迁移文件成功**
- **实现**: 实现目标

**迁移文件失败**
- **避免**: 避免失败

**迁移文件风险**
- **评估**: 评估风险

**迁移文件收益**
- **最大化**: 最大化收益

**迁移文件成本**
- **最小化**: 最小化成本

**迁移文件价值**
- **提升**: 提升价值

**迁移文件影响**
- **正面**: 正面影响

**迁移文件挑战**
- **应对**: 应对挑战

**迁移文件机遇**
- **抓住**: 抓住机遇

**迁移文件趋势**
- **跟随**: 跟随趋势

**迁移文件变化**
- **适应**: 适应变化

**迁移文件稳定**
- **保持**: 保持稳定

**迁移文件可靠**
- **确保**: 确保可靠

**迁移文件安全**
- **保障**: 保障安全

**迁移文件高效**
- **提高**: 提高效率

**迁移文件准确**
- **保证**: 保证准确

**迁移文件完整**
- **维护**: 维护完整

**迁移文件一致**
- **保持**: 保持一致

**迁移文件透明**
- **公开**: 公开透明

**迁移文件可追溯**
- **记录**: 记录变更

**迁移文件可审计**
- **审查**: 审查变更

**迁移文件可恢复**
- **备份**: 备份恢复

**迁移文件可扩展**
- **设计**: 设计扩展

**迁移文件可维护**
- **简化**: 简化维护

**迁移文件可测试**
- **验证**: 验证变更

**迁移文件可部署**
- **自动化**: 自动化部署

**迁移文件可监控**
- **日志**: 监控日志

**迁移文件可支持**
- **社区**: 社区支持

**迁移文件可培训**
- **文档**: 提供文档

**迁移文件可协作**
- **团队**: 团队协作

**迁移文件可分享**
- **Git**: 通过Git分享

**迁移文件可归档**
- **压缩**: 压缩归档

**迁移文件可清理**
- **删除**: 删除旧文件

**迁移文件可恢复**
- **备份**: 从备份恢复

**迁移文件可审计**
- **审查**: 审查变更

**迁移文件可追溯**
- **记录**: 记录变更

**迁移文件可测试**
- **验证**: 验证变更

**迁移文件可部署**
- **自动化**: 自动化部署

**迁移文件可监控**
- **日志**: 监控日志

**迁移文件可支持**
- **社区**: 社区支持

**迁移文件可培训**
- **文档**: 提供文档

**迁移文件可协作**
- **团队**: 团队协作

**迁移文件可分享**
- **Git**: 通过Git分享

**迁移文件可归档**
- **压缩**: 压缩归档

**迁移文件可清理**
- **删除**: 删除旧文件

**迁移文件可恢复**
- **备份**: 从备份恢复

**迁移文件可审计**
- **审查**: 审查变更

**迁移文件可追溯**
- **记录**: 记录变更

**迁移文件可测试**
- **验证**: 验证变更

**迁移文件可部署**
- **自动化**: 自动化部署

**迁移文件可监控**
- **日志**: 监控日志

**迁移文件可支持**
- **社区**: 社区支持

**迁移文件可培训**
- **文档**: 提供文档

**迁移文件可协作**
- **团队**: 团队协作

**迁移文件可分享**
- **Git**: 通过Git分享

**迁移文件可归档**
- **压缩**: 压缩归档

**迁移文件可清理**
- **删除**: 删除旧文件

**迁移文件可恢复**
- **备份**: 从备份恢复

**迁移文件可审计**
- **审查**: 审查变更

**迁移文件可追溯**
- **记录**: 记录变更

**迁移文件可测试**
- **验证**: 验证变更

**迁移文件可部署**
- **自动化**: 自动化部署

**迁移文件可监控**
- **日志**: 监控日志

**迁移文件可支持**
- **社区**: 社区支持

**迁移文件可培训**
- **文档**: 提供文档

**迁移文件可协作**
- **团队**: 团队协作

**迁移文件可分享**
- **Git**: 通过Git分享

**迁移文件可归档**
- **压缩**: 压缩归档

**迁移文件可清理**
- **删除**: 删除旧文件

**迁移文件可恢复**
- **备份**: 从备份恢复

**迁移文件可审计**
- **审查**: 审查变更

**迁移文件可追溯**
- **记录**: 记录变更

**迁移文件可测试**
- **验证**: 验证变更

**迁移文件可部署**
- **自动化**: 自动化部署

**迁移文件可监控**
- **日志**: 监控日志

**迁移文件可支持**
- **社区**: 社区支持

**迁移文件可培训**
- **文档**: 提供文档

**迁移文件可协作**
- **团队**: 团队协作

**迁移文件可分享**
- **Git**: 通过Git分享

**迁移文件可归档**
- **压缩**: 压缩归档

**迁移文件可清理**
- **删除**: 删除旧文件

**迁移文件可恢复**
- **备份**: 从备份恢复

**迁移文件可审计**
- **审查**: 审查变更

**迁移文件可追溯**
- **记录**: 记录变更

**迁移文件可测试**
- **验证**: 验证变更

**迁移文件可部署**
- **自动化**: 自动化部署

**迁移文件可......**

## 迁移机制详解

royale-arena项目采用SQLx-CLI工具进行数据库迁移管理，其核心机制基于`.up.sql`和`.down.sql`文件对。

- **.up.sql 文件**: 该文件包含用于**应用**数据库变更的SQL语句。当执行`sqlx migrate run`命令时，SQLx-CLI会按时间戳顺序查找所有未应用的`.up.sql`文件，并执行其中的SQL脚本。这些脚本通常用于创建表、添加列、插入初始数据或修改约束等正向操作。
- **.down.sql 文件**: 该文件包含用于**回滚**数据库变更的SQL语句。当执行`sqlx migrate revert`命令时，SQLx-CLI会按与`.up.sql`相反的顺序（通常是倒序）执行对应的`.down.sql`文件。这些脚本旨在将数据库恢复到应用`.up.sql`之前的状态，例如删除由`.up.sql`创建的表或删除插入的数据。

这种成对的机制确保了数据库变更的可逆性，是安全开发和部署的关键。SQLx-CLI通过在数据库中维护一个名为`_sqlx_migrations`的特殊表来跟踪哪些迁移已经被应用。每次成功应用一个`.up.sql`文件后，其时间戳和校验和会被记录在该表中；而当回滚时，相应的记录会被移除。

## 初始化数据库结构迁移分析

本节分析`20250825105153_init_schema.up.sql`和`20250825105153_init_schema.down.sql`两个文件，它们共同构成了项目的初始数据库结构。

### .up.sql 文件分析

该文件通过一系列`CREATE TABLE`语句定义了6个核心数据表，其执行顺序至关重要，因为后续的表可能依赖于前面创建的表（通过外键）。

1.  **`admin_users` (管理员账户表)**: 这是权限最高的用户表，存储系统管理员信息。包含ID、用户名、密码、是否为超级管理员等字段，并为用户名创建了索引以加速登录查询。
2.  **`rule_templates` (游戏规则模版表)**: 存储可复用的游戏规则配置。其`rules_config`字段使用JSON类型，可以灵活地存储复杂的规则，如游戏时长、地图地点、玩家属性等。
3.  **`games` (游戏实例表)**: 代表一个具体的游戏实例。它通过`rule_template_id`外键关联到`rule_templates`表，实现了规则的复用。状态字段使用ENUM类型，限制为'waiting', 'running', 'paused', 'ended'四种。
4.  **`actors` (演员账户表)**: 存储参与某个游戏的玩家信息。通过`game_id`外键与`games`表关联，且设置了`ON DELETE CASCADE`，意味着当一个游戏被删除时，其所有演员账户也会被自动删除。
5.  **`game_logs` (游戏日志表)**: 记录游戏运行过程中的日志。通过`game_id`和`player_id`外键分别关联到`games`和`actors`表。`player_id`的外键设置为`ON DELETE SET NULL`，表示即使玩家被删除，其相关的日志记录仍会保留，但`player_id`字段会被置为NULL。
6.  **`kill_records` (击杀记录表)**: 记录玩家间的击杀事件。`killer_id`和`victim_id`都外键指向`actors`表，且都设置了`ON DELETE CASCADE`，确保数据一致性。

**执行顺序**: 这6个`CREATE TABLE`语句必须按此顺序执行，因为`games`依赖`rule_templates`，`actors`和`game_logs`依赖`games`，`kill_records`又依赖`actors`。

```
-- migrations/20250825105153_init_schema.up.sql
-- 注意：不包含 DROP DATABASE, CREATE DATABASE, USE

-- 1. 管理员账户表
CREATE TABLE IF NOT EXISTS admin_users (
    id VARCHAR(36) PRIMARY KEY COMMENT '管理员唯一标识符(UUID)',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '管理员用户名',
    password VARCHAR(255) NOT NULL COMMENT '管理员密码(密文存储)',
    is_super_admin BOOLEAN NOT NULL DEFAULT FALSE COMMENT '是否为超级管理员',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_admin_users_username (username)
) COMMENT '管理员账户表';

-- 2. 游戏规则模版表
CREATE TABLE IF NOT EXISTS rule_templates (
    id VARCHAR(36) PRIMARY KEY COMMENT '模版唯一标识符(UUID)',
    template_name VARCHAR(100) NOT NULL COMMENT '模版名称',
    description TEXT COMMENT '模版描述',
    is_active BOOLEAN NOT NULL DEFAULT TRUE COMMENT '模版是否激活',
    rules_config JSON NOT NULL COMMENT '完整的游戏规则配置(JSON格式)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '模版创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '模版更新时间',
    
    INDEX idx_rule_templates_name (template_name),
    INDEX idx_rule_templates_active (is_active)
) COMMENT '游戏规则模版表';

-- 3. 游戏实例表
CREATE TABLE IF NOT EXISTS games (
    id VARCHAR(36) PRIMARY KEY COMMENT '游戏唯一标识符(UUID)',
    name VARCHAR(100) NOT NULL COMMENT '游戏名称',
    description TEXT COMMENT '游戏描述',
    director_password VARCHAR(50) NOT NULL COMMENT '导演密码',
    max_players INT NOT NULL DEFAULT 100 COMMENT '最大玩家数量',
    status ENUM('waiting', 'running', 'paused', 'ended') NOT NULL DEFAULT 'waiting' COMMENT '游戏状态',
    -- 关联规则模板
    rule_template_id VARCHAR(36) NULL COMMENT '关联的规则模板ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (rule_template_id) REFERENCES rule_templates(id) ON DELETE SET NULL,
    
    INDEX idx_games_status (status)
) COMMENT '游戏实例表';

-- 4. 演员账户表
CREATE TABLE IF NOT EXISTS actors (
    id VARCHAR(36) PRIMARY KEY COMMENT '演员唯一标识符(UUID)',
    game_id VARCHAR(36) NOT NULL COMMENT '所属游戏ID',
    name VARCHAR(50) NOT NULL COMMENT '演员名称',
    password VARCHAR(8) NOT NULL COMMENT '演员密码(6-8位字母数字)',
    team_id INT NOT NULL DEFAULT 0 COMMENT '队伍ID，用于标识玩家所属队伍，0表示无队伍',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,
    
    INDEX idx_actors_game_id (game_id),
    INDEX idx_actors_name (name)
) COMMENT '演员账户表';

-- 5. 游戏日志表
CREATE TABLE IF NOT EXISTS game_logs (
    `id` varchar(36) PRIMARY KEY COMMENT '日志唯一标识符(UUID)',
    `game_id` varchar(36) NOT NULL COMMENT '所属游戏ID',
    `type` enum('SystemNotice','UserDirected') NOT NULL COMMENT '日志级别',
    `message` text NOT NULL COMMENT '日志消息',
    `player_id` varchar(36) NOT NULL COMMENT '相关玩家ID',
    `timestamp` timestamp DEFAULT CURRENT_TIMESTAMP COMMENT '日志时间戳',
    FOREIGN KEY (`game_id`) REFERENCES games(id) ON DELETE CASCADE,
    FOREIGN KEY (`player_id`) REFERENCES actors(id) ON DELETE CASCADE,
    
    INDEX idx_game_logs_game_id (game_id),
    INDEX idx_game_logs_type (type),
    INDEX idx_game_logs_timestamp (timestamp)
) COMMENT '游戏日志表';

-- 6. 击杀记录表
CREATE TABLE IF NOT EXISTS kill_records (
    id VARCHAR(36) PRIMARY KEY COMMENT '击杀记录唯一标识符(UUID)',
    game_id VARCHAR(36) NOT NULL COMMENT '所属游戏ID',
    killer_id VARCHAR(36) NULL COMMENT '击杀者ID（可为空，表示非玩家击杀）',
    victim_id VARCHAR(36) NOT NULL COMMENT '被击杀者ID',
    kill_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '击杀时间',
    cause VARCHAR(50) NOT NULL COMMENT '击杀原因（如：武器、缩圈等）',
    weapon VARCHAR(50) NULL COMMENT '使用的武器/方式',
    location VARCHAR(100) NULL COMMENT '击杀地点',
    FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,
    FOREIGN KEY (killer_id) REFERENCES actors(id) ON DELETE CASCADE,
    FOREIGN KEY (victim_id) REFERENCES actors(id) ON DELETE CASCADE,
    
    INDEX idx_kill_records_game_id (game_id),
    INDEX idx_kill_records_killer_id (killer_id),
    INDEX idx_kill_records_victim_id (victim_id),
    INDEX idx_kill_records_kill_time (kill_time)
) COMMENT '击杀记录表';
```

**图示来源**
- [20250825105153_init_schema.up.sql](file://backend\migrations\20250825105153_init_schema.up.sql#L1-L95)

**本节来源**
- [20250825105153_init_schema.up.sql](file://backend\migrations\20250825105153_init_schema.up.sql#L1-L95)

### .down.sql 文件分析

该文件的`20250825105153_init_schema.down.sql`脚本非常直接，它通过一系列`DROP TABLE IF EXISTS`语句来删除所有在`.up.sql`中创建的表。

**执行顺序**: 删除表的顺序与创建顺序**相反**。这是为了遵守数据库的外键约束。例如，必须先删除依赖`actors`表的`kill_records`和`game_logs`表，然后才能删除`actors`表本身。脚本中列出的顺序（kill_records -> game_logs -> actors -> games -> rule_templates -> admin_users）正是遵循了这一原则，确保了回滚操作的顺利进行。

**本节来源**
- [20250825105153_init_schema.down.sql](file://backend\migrations\20250825105153_init_schema.down.sql#L1-L10)

## 填充测试数据迁移分析

本节分析`20250825105158_seed_test_data.up.sql`和`20250825105158_seed_test_data.down.sql`两个文件，它们负责为开发和测试环境填充初始数据。

### .up.sql 文件分析

该文件使用`INSERT IGNORE INTO`语句向已创建的表中插入测试数据。`IGNORE`关键字可以防止因主键或唯一键冲突而导致的错误，使得该脚本可以安全地重复运行。

1.  **`admin_users`**: 插入了两个测试管理员账户，ID分别为`3e6aa7c8-...`和`00f2bd7d-...`，用户名为'a'和'b'，密码已加密存储。其中'a'是超级管理员。
2.  **`rule_templates`**: 插入了两个游戏规则模板：“经典模式”和“快速模式”。它们的`rules_config`字段包含了详细的JSON配置，如白天/夜晚时长、地图地点列表等。
3.  **`games`**: 插入了两个测试游戏实例，“测试游戏1”和“测试游戏2”，并指定了各自的导演密码。
4.  **`actors`**: 为上述两个游戏实例各插入了两个测试演员账户。

**执行顺序**: 数据插入的顺序必须遵循外键依赖关系。必须先插入`admin_users`和`rule_templates`，然后才能插入引用它们的`games`；必须先插入`games`，然后才能插入属于这些游戏的`actors`。

**本节来源**
- [20250825105158_seed_test_data.up.sql](file://backend\migrations\20250825105158_seed_test_data.up.sql#L1-L30)

### .down.sql 文件分析

该文件的`20250825105158_seed_test_data.down.sql`脚本通过`DELETE FROM`语句来清空所有表中的数据。

**执行顺序**: 删除数据的顺序同样需要考虑外键约束。脚本中先删除`kill_records`和`game_logs`，然后是`actors`，最后是`games`、`rule_templates`和`admin_users`。这与`.up.sql`的插入顺序相反，确保了没有外键冲突。

**本节来源**
- [20250825105158_seed_test_data.down.sql](file://backend\migrations\20250825105158_seed_test_data.down.sql#L1-L19)

## 游戏规则配置独立化迁移分析

本节分析`20250915152136_game_rule_json.up.sql`和`20250915152136_game_rule_json.down.sql`两个文件，它们实现了游戏规则配置的独立化，使每个游戏实例拥有自己独立的规则副本。

### .up.sql 文件分析

该迁移脚本的核心目标是将游戏规则从共享的`rule_templates`表解耦，使每个`games`实例都能拥有独立的`rules_config`。其步骤如下：

1.  **添加新字段**: 首先，在`games`表中添加一个名为`rules_config`的新JSON字段，初始允许为NULL。
2.  **数据迁移**: 将现有游戏中通过`rule_template_id`关联的规则模板的`rules_config`复制到该游戏的`rules_config`字段中。
3.  **填充默认值**: 对于那些没有关联任何规则模板的游戏，为其`rules_config`字段设置一个预定义的默认规则配置。
4.  **修改字段约束**: 将`rules_config`字段修改为`NOT NULL`，确保每个游戏都有明确的规则。
5.  **解除外键依赖**: 删除`games`表对`rule_templates`表的外键约束。
6.  **删除旧字段**: 最后，删除不再需要的`rule_template_id`字段。

这一系列操作实现了从“引用模板”到“拥有独立副本”的转变，极大地提高了游戏配置的灵活性。

**本节来源**
- [20250915152136_game_rule_json.up.sql](file://backend\migrations\20250915152136_game_rule_json.up.sql#L1-L29)

### .down.sql 文件分析

该文件的`20250915152136_game_rule_json.down.sql`脚本用于回滚上述变更，恢复到旧的架构。

1.  **重建外键字段**: 首先，重新在`games`表中添加`rule_template_id`字段。
2.  **删除独立配置**: 删除`games`表中的`rules_config`字段。
3.  **恢复外键约束**: 重新建立`games.rule_template_id`到`rule_templates.id`的外键约束。

这个回滚过程假设了`rule_templates`表仍然存在，并且`games.rules_config`中的数据可以被丢弃。它将系统恢复到所有游戏共享规则模板的状态。

**本节来源**
- [20250915152136_game_rule_json.down.sql](file://backend\migrations\20250915152136_game_rule_json.down.sql#L1-L14)

## 使用SQLx-CLI进行迁移管理

SQLx-CLI是管理royale-arena项目数据库迁移的核心工具。以下是其主要命令和工作流程。

### 1. 安装与配置

首先，需要安装`sqlx-cli`工具，并确保包含了`mysql`特性。
```bash
cargo install --features postgres,mysql sqlx-cli
```

然后，将项目根目录下的`.env.example`文件复制为`.env`，并根据你的数据库环境（如MySQL服务器地址、端口、用户名、密码、数据库名）修改`DATABASE_URL`环境变量。

### 2. 创建新的迁移

当需要修改数据库时，使用`sqlx migrate add`命令创建一个新的迁移对。
```bash
# 在 backend/royale-arena-backend 目录下执行
sqlx migrate add -r add_new_column
```
这将生成两个新文件：`{timestamp}_add_new_column.up.sql` 和 `{timestamp}_add_new_column.down.sql`。开发者需要手动在这两个文件中编写相应的SQL语句。

### 3. 应用迁移

使用`sqlx migrate run`命令将所有未应用的迁移应用到数据库。
```bash
sqlx migrate run
```
该命令会连接到`.env`文件中`DATABASE_URL`指定的数据库，按时间戳顺序执行所有未记录在`_sqlx_migrations`表中的`.up.sql`脚本。

### 4. 回滚迁移

使用`sqlx migrate revert`命令回滚最近一次应用的迁移。
```bash
sqlx migrate revert
```
该命令会执行最近一次`.up.sql`所对应的`.down.sql`脚本，并从`_sqlx_migrations`表中移除该迁移的记录。

### 5. 在测试中使用迁移

SQLx提供了一个强大的宏`#[sqlx::test]`，可以在Rust测试中自动管理数据库。
```rust
use sqlx::MySqlPool;

#[sqlx::test(migrations = "../migrations")]
async fn test_database_functionality(pool: MySqlPool) {
    // 在此函数运行前，会自动创建一个临时的、干净的测试数据库，
    // 并应用 migrations 目录下的所有迁移。
    // pool 参数已连接到这个临时数据库。
    // 测试结束后，临时数据库会被自动销毁，保证测试的隔离性。
}
```

**本节来源**
- [backend/migrations/README.md](file://backend\migrations\README.md#L1-L89)

## 最佳实践与注意事项

为了安全、高效地进行数据库迁移，遵循以下最佳实践至关重要。

1.  **编写可逆迁移**: 始终确保`.down.sql`脚本能够正确地将数据库恢复到应用`.up.sql`之前的状态。对于数据插入操作，`.down.sql`应删除这些数据；对于表结构变更，`.down.sql`应恢复原状。避免在`.down.sql`中使用`DROP DATABASE`等破坏性操作。
2.  **测试数据管理**: 将测试数据的填充（如`seed_test_data`）与数据库结构的创建（如`init_schema`）分离。这使得在生产环境中可以只应用结构变更，而不填充测试数据。使用`INSERT IGNORE`或`CREATE IF NOT EXISTS`等幂等操作，使迁移脚本可以安全地重复运行。
3.  **版本控制协同**: 将迁移文件纳入Git等版本控制系统。团队成员在拉取最新代码后，只需运行`sqlx migrate run`即可使本地数据库与代码同步。**切勿修改已应用的迁移文件**，如果需要修正，应创建一个新的迁移来修复。
4.  **安全执行迁移流程**:
    *   **开发环境**: 可以自由地应用和回滚迁移，用于功能开发和调试。
    *   **测试环境**: 在部署新版本前，自动运行`sqlx migrate run`来更新数据库，确保测试环境与代码一致。
    *   **生产环境**: 操作需极其谨慎。应在非高峰时段进行，并提前在预发布环境充分测试。执行前务必备份数据库。建议在部署脚本中包含迁移命令，并确保有明确的回滚计划（即`sqlx migrate revert`）。`.down.sql`脚本在生产环境的回滚操作中扮演着关键角色。
5.  **环境配置**: 确保`.env`文件中的`DATABASE_URL`准确指向目标环境的数据库实例。可以使用不同的`.env`文件（如`.env.development`, `.env.production`）来区分环境。

**本节来源**
- [backend/migrations/README.md](file://backend\migrations\README.md#L85-L89)