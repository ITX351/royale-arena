# 模式详解

<cite>
**本文档引用的文件**   
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql)
- [add_game_status_hidden_deleted.up.sql](file://backend/migrations/20250826121055_add_game_status_hidden_deleted.up.sql)
- [Cargo.toml](file://backend/Cargo.toml)
- [README.md](file://backend/migrations/README.md)
- [admin_auth_integration.rs](file://backend/tests/admin_auth_integration.rs)
- [models.rs](file://backend/src/admin/models.rs)
- [service.rs](file://backend/src/admin/service.rs)
- [game/models.rs](file://backend/src/game/models.rs)
- [game/service.rs](file://backend/src/game/service.rs)
- [game/handlers.rs](file://backend/src/game/handlers.rs)
- [game.ts](file://frontend/src/types/game.ts)
- [HomePage.vue](file://frontend/src/views/HomePage.vue)
- [AdminGamesPage.vue](file://frontend/src/views/admin/AdminGamesPage.vue)
</cite>

## 更新摘要
**已更新内容**   
- 扩展了 `games` 表的 `status` 字段，新增 'hidden' 和 'deleted' 两种状态
- 更新了游戏状态枚举的文档说明，包含新增状态的业务语义
- 更新了实体关系图，反映新的状态值
- 新增了关于游戏筛选逻辑的文档说明
- 更新了设计逻辑部分，解释新增状态的使用场景

**新增部分**   
- 新增了游戏筛选类型（GameFilterType）的说明
- 新增了前端UI中游戏状态展示的说明

**已弃用部分**   
- 无

**源码追踪系统更新**   
- 新增了后端 `game/models.rs`、`game/service.rs`、`game/handlers.rs` 文件的引用
- 新增了前端 `game.ts`、`HomePage.vue`、`AdminGamesPage.vue` 文件的引用
- 更新了数据库迁移文件的引用

## 目录
1. [引言](#引言)
2. [核心表结构分析](#核心表结构分析)
3. [表间关系与实体关系图](#表间关系与实体关系图)
4. [设计逻辑与业务语义](#设计逻辑与业务语义)
5. [Rust后端与SQLx集成](#rust后端与sqlx集成)
6. [总结](#总结)

## 引言
本文档基于 `royale-arena` 项目的数据库迁移文件 `init_schema.up.sql` 和 `add_game_status_hidden_deleted.up.sql`，对数据库模式进行详细解析。重点分析 `admin_users`、`games`、`actors` 和 `rule_templates` 四张核心表的结构设计、字段约束、业务语义以及它们之间的关系。特别关注了最近对 `games` 表 `status` 字段的扩展，新增了 'hidden' 和 'deleted' 状态。同时，结合项目中 `Cargo.toml` 和测试代码的信息，阐述如何通过 Rust 的 SQLx 库实现类型安全的数据库查询，确保数据一致性。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql)
- [add_game_status_hidden_deleted.up.sql](file://backend/migrations/20250826121055_add_game_status_hidden_deleted.up.sql)

## 核心表结构分析

### admin_users 表
此表用于存储系统管理员账户信息。

**: 结构**
```sql
CREATE TABLE IF NOT EXISTS admin_users (
    id VARCHAR(36) PRIMARY KEY COMMENT '管理员唯一标识符(UUID)',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '管理员用户名',
    password VARCHAR(255) NOT NULL COMMENT '管理员密码(密文存储)',
    is_super_admin BOOLEAN NOT NULL DEFAULT FALSE COMMENT '是否为超级管理员',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_admin_users_username (username)
) COMMENT '管理员账户表';
```

**: 字段说明**
- **id**: 主键，使用 VARCHAR(36) 存储 UUID，确保全局唯一性。
- **username**: 管理员用户名，`NOT NULL` 且 `UNIQUE`，保证每个用户名的唯一性。
- **password**: 存储加密后的密码，`NOT NULL`，长度为255以适应不同加密算法的输出。
- **is_super_admin**: 布尔值，标识是否为超级管理员，`DEFAULT FALSE` 表示默认为普通管理员。
- **created_at**: 记录管理员账户的创建时间，由数据库自动设置为当前时间戳。
- **updated_at**: 记录管理员账户信息的最后更新时间，当记录被修改时，数据库会自动更新此字段。
- **idx_admin_users_username**: 为 `username` 字段创建的索引，以加速基于用户名的查询。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql#L3-L14)

### games 表
此表用于存储每个游戏实例的基本信息。

**: 结构**
```sql
CREATE TABLE IF NOT EXISTS games (
    id VARCHAR(36) PRIMARY KEY COMMENT '游戏唯一标识符(UUID)',
    name VARCHAR(100) NOT NULL COMMENT '游戏名称',
    description TEXT COMMENT '游戏描述',
    director_password VARCHAR(50) NOT NULL COMMENT '导演密码',
    max_players INT NOT NULL DEFAULT 100 COMMENT '最大玩家数量',
    status ENUM('waiting', 'running', 'paused', 'ended', 'hidden', 'deleted') NOT NULL DEFAULT 'waiting' COMMENT '游戏状态',
    rule_template_id VARCHAR(36) NULL COMMENT '关联的规则模板ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (rule_template_id) REFERENCES rule_templates(id) ON DELETE SET NULL,
    
    INDEX idx_games_status (status)
) COMMENT '游戏实例表';
```

**: 字段说明**
- **id**: 主键，使用 UUID。
- **name**: 游戏名称，`NOT NULL`。
- **description**: 游戏的详细描述，使用 TEXT 类型以支持较长文本。
- **director_password**: 导演（游戏创建者）的密码，`NOT NULL`。
- **max_players**: 最大玩家数量，`NOT NULL`，默认值为100。
- **status**: 枚举类型（ENUM），定义了游戏的六种状态：'waiting'（等待中）、'running'（进行中）、'paused'（已暂停）、'ended'（已结束）、'hidden'（已隐藏）、'deleted'（已删除）。`DEFAULT 'waiting'` 表示新创建的游戏默认处于等待状态。新增的 'hidden' 状态用于将游戏从公开列表中隐藏，但仍保留在数据库中；'deleted' 状态表示游戏已被删除，通常只对管理员可见。
- **rule_template_id**: 外键，关联 `rule_templates` 表的 `id`。`NULL` 表示游戏可以不使用规则模板。`ON DELETE SET NULL` 约束意味着当关联的规则模板被删除时，此字段将被设置为 NULL，而不是删除整个游戏记录，保证了数据的完整性。
- **created_at** 和 **updated_at**: 自动管理的时间戳。
- **idx_games_status**: 为 `status` 字段创建的索引，便于快速查询特定状态的游戏。

**Section sources**   
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql#L26-L47)
- [add_game_status_hidden_deleted.up.sql](file://backend/migrations/20250826121055_add_game_status_hidden_deleted.up.sql#L4-L6)

### actors 表
此表用于存储游戏中演员（玩家）的信息。

**: 结构**
```sql
CREATE TABLE IF NOT EXISTS actors (
    id VARCHAR(36) PRIMARY KEY COMMENT '演员唯一标识符(UUID)',
    game_id VARCHAR(36) NOT NULL COMMENT '所属游戏ID',
    name VARCHAR(50) NOT NULL COMMENT '演员名称',
    password VARCHAR(8) NOT NULL COMMENT '演员密码(6-8位字母数字)',
    team_id INT NOT NULL DEFAULT 0 COMMENT '队伍ID，用于标识玩家所属队伍，0表示无队伍',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,
    
    INDEX idx_actors_game_id (game_id),
    INDEX idx_actors_name (name)
) COMMENT '演员账户表';
```

**: 字段说明**
- **id**: 主键，UUID。
- **game_id**: 外键，关联 `games` 表的 `id`。`NOT NULL` 表示每个演员必须属于一个游戏。`ON DELETE CASCADE` 约束意味着当一个游戏被删除时，其下的所有演员记录也会被自动删除。
- **name**: 演员名称，`NOT NULL`。
- **password**: 演员密码，`NOT NULL`，长度固定为8位，符合业务要求。
- **team_id**: 队伍ID，`NOT NULL`，默认值为0，表示未加入任何队伍。
- **created_at** 和 **updated_at**: 自动管理的时间戳。
- **idx_actors_game_id** 和 **idx_actors_name**: 分别为 `game_id` 和 `name` 创建的索引，用于优化按游戏或按名称查询演员的性能。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql#L49-L66)

### rule_templates 表
此表用于存储可重用的游戏规则配置模板。

**: 结构**
```sql
CREATE TABLE IF NOT EXISTS rule_templates (
    id VARCHAR(36) PRIMARY KEY COMMENT '模版唯一标识符(UUID)',
    template_name VARCHAR(100) NOT NULL COMMENT '模版名称',
    description TEXT COMMENT '模版描述',
    is_active BOOLEAN NOT NULL DEFAULT TRUE COMMENT '模版是否激活',
    rules_config JSON NOT NULL COMMENT '完整的游戏规则配置(JSON格式)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '模版创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '模版更新时间',
    
    INDEX idx_rule_templates_name (template_name),
    INDEX idx_rule_templates_active (is_active)
) COMMENT '游戏规则模版表';
```

**: 字段说明**
- **id**: 主键，UUID。
- **template_name**: 模板名称，`NOT NULL`。
- **description**: 模板的描述信息。
- **is_active**: 布尔值，标识模板是否处于激活状态，`DEFAULT TRUE`。
- **rules_config**: 核心字段，使用 JSON 数据类型存储完整的、结构化的游戏规则配置。这使得可以灵活地定义和存储复杂的规则，如游戏流程、地图、玩家属性等，而无需为每个规则项创建单独的数据库列。
- **created_at** 和 **updated_at**: 自动管理的时间戳。
- **idx_rule_templates_name** 和 **idx_rule_templates_active**: 为名称和激活状态创建的索引。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql#L16-L24)

## 表间关系与实体关系图

### 表间关系
- **1对多关系**: `games` 表与 `actors` 表之间存在典型的1对多关系。一个游戏（`games`）可以有多个演员（`actors`），但一个演员只能属于一个游戏。这通过 `actors` 表中的 `game_id` 外键实现。
- **可选关联**: `games` 表与 `rule_templates` 表之间是可选的1对1关系。一个游戏可以关联一个规则模板，但也可以不关联。这通过 `games` 表中的 `rule_template_id` 外键（允许为 NULL）实现。
- **级联删除**: `actors` 表对 `games` 表设置了 `ON DELETE CASCADE`，确保游戏删除时其演员数据也被清理。
- **置空处理**: `games` 表对 `rule_templates` 表设置了 `ON DELETE SET NULL`，确保规则模板删除时，已使用该模板的游戏记录不会丢失。

### 实体关系图 (ER Diagram)
```
erDiagram
admin_users {
VARCHAR(36) id PK
VARCHAR(50) username UK
VARCHAR(255) password
BOOLEAN is_super_admin
TIMESTAMP created_at
TIMESTAMP updated_at
}
rule_templates {
VARCHAR(36) id PK
VARCHAR(100) template_name
TEXT description
BOOLEAN is_active
JSON rules_config
TIMESTAMP created_at
TIMESTAMP updated_at
}
games {
VARCHAR(36) id PK
VARCHAR(100) name
TEXT description
VARCHAR(50) director_password
INT max_players
ENUM status
VARCHAR(36) rule_template_id FK
TIMESTAMP created_at
TIMESTAMP updated_at
}
actors {
VARCHAR(36) id PK
VARCHAR(36) game_id FK
VARCHAR(50) name
VARCHAR(8) password
INT team_id
TIMESTAMP created_at
TIMESTAMP updated_at
}
admin_users ||--o{ games : "创建"
rule_templates ||--o{ games : "被引用"
games ||--o{ actors : "包含"
```

**Diagram sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql)

## 设计逻辑与业务语义

### 状态字段的枚举使用
`games` 表的 `status` 字段使用 ENUM 类型，将游戏状态限制在预定义的六个值内。这种设计的优点是：
1.  **数据完整性**: 防止插入无效或拼写错误的状态值。
2.  **可读性**: 状态值是语义化的字符串，比数字ID更易于理解和调试。
3.  **简化逻辑**: 应用层代码可以直接比较字符串状态，逻辑清晰。

新增的 'hidden' 和 'deleted' 状态扩展了游戏的生命周期管理：
- **hidden**: 用于将游戏从公开的游戏列表中隐藏，但游戏数据仍然完整保留。这适用于需要临时下架或归档的游戏，普通用户无法看到，但管理员仍可访问和管理。
- **deleted**: 表示游戏已被删除。在当前实现中，通过 `DELETE FROM games` 语句直接从数据库中移除记录。此状态在业务逻辑中主要用于管理员界面的筛选和审计。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql)
- [add_game_status_hidden_deleted.up.sql](file://backend/migrations/20250826121055_add_game_status_hidden_deleted.up.sql)
- [seed_test_data.up.sql](file://backend/migrations/20250825105158_seed_test_data.up.sql)
- [game/models.rs](file://backend/src/game/models.rs#L3-L25)
- [game/service.rs](file://backend/src/game/service.rs#L150-L180)
- [game/handlers.rs](file://backend/src/game/handlers.rs#L45-L55)

### 时间戳的自动管理
所有核心表都包含 `created_at` 和 `updated_at` 字段，并利用数据库的 `DEFAULT CURRENT_TIMESTAMP` 和 `ON UPDATE CURRENT_TIMESTAMP` 特性。这种设计的优点是：
1.  **一致性**: 确保所有记录的时间戳都由数据库统一生成，避免了应用层时钟不同步的问题。
2.  **可靠性**: 即使应用层代码出错，只要记录被创建或更新，时间戳就能被正确记录。
3.  **减少应用负担**: 应用层无需手动设置这些时间戳。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql)

### JSON 字段的灵活性
`rule_templates` 表的 `rules_config` 字段使用 JSON 类型，这是设计上的一个关键决策。它允许：
1.  **高度灵活性**: 可以存储任意结构的规则配置，未来添加新规则时，无需修改数据库表结构（ALTER TABLE），只需更新JSON内容。
2.  **结构化数据**: JSON 格式天然支持嵌套和复杂数据结构，非常适合表示游戏规则。
3.  **与应用层映射**: 在 Rust 后端，可以使用 `serde` 库轻松地将这个 JSON 字段反序列化为一个结构化的 Rust 结构体，实现类型安全。

**Section sources**
- [init_schema.up.sql](file://backend/migrations/20250825105153_init_schema.up.sql)

### 游戏筛选逻辑
系统实现了灵活的游戏筛选功能，通过 `GameFilterType` 枚举定义了多种筛选类型：
- **All**: 显示所有非隐藏和非删除的游戏（默认筛选）。
- **Active**: 显示活动中（等待中、进行中、已暂停）的游戏。
- **Waiting/Running/Ended/Hidden/Deleted**: 分别显示对应状态的游戏。

在后端 `GameService::get_games` 方法中，根据筛选类型动态构建 SQL 查询。对于 `All` 筛选，会排除 `hidden` 和 `deleted` 状态的游戏。前端通过 `GameListQuery` 参数传递筛选条件，实现了用户友好的游戏列表过滤。

**Section sources**
- [game/models.rs](file://backend/src/game/models.rs#L100-L140)
- [game/service.rs](file://backend/src/game/service.rs#L150-L180)
- [game/handlers.rs](file://backend/src/game/handlers.rs#L65-L74)
- [game.ts](file://frontend/src/types/game.ts#L10-L21)
- [HomePage.vue](file://frontend/src/views/HomePage.vue#L25-L35)
- [AdminGamesPage.vue](file://frontend/src/views/admin/AdminGamesPage.vue#L35-L55)

## Rust后端与SQLx集成

### SQLx 依赖配置
项目通过 `Cargo.toml` 文件声明了对 SQLx 的依赖，其关键配置如下：
```toml
[dependencies]
sqlx = { version = "0.8.6", features = ["runtime-tokio-rustls", "mysql", "chrono", "uuid"] }
```
- **mysql**: 启用对 MySQL 数据库的支持。
- **chrono**: 启用对 `chrono` 库的支持，使得数据库中的 `TIMESTAMP` 类型可以无缝映射到 Rust 的 `DateTime<Utc>` 类型。
- **uuid**: 启用对 `uuid` 库的支持，使得数据库中的 `VARCHAR(36)` UUID 字段可以无缝映射到 Rust 的 `Uuid` 类型。
- **runtime-tokio-rustls**: 指定运行时和TLS库。

### 类型安全的数据库查询
SQLx 的核心优势在于其编译时检查能力。它通过以下方式实现类型安全：
1.  **编译时查询验证**: SQLx 可以在编译时连接到数据库（或读取查询元数据），检查 SQL 查询的语法和语义是否正确，确保表名、列名、数据类型都匹配。
2.  **类型推导**: SQLx 能够根据查询结果的列，自动推导出 Rust 结构体的字段类型。例如，`admin_users` 表的 `AdminUser` 模型通过 `#[derive(sqlx::FromRow)]` 宏，使得 `sqlx::query_as::<_, AdminUser>()` 能够将查询结果安全地映射到该结构体上。
3.  **与 Serde 集成**: 结合 `serde` 库，SQLx 可以直接将查询结果（如 `rules_config` 字段的 JSON 数据）反序列化为复杂的 Rust 结构体，确保了从数据库到应用层的数据一致性。

### 数据库迁移工作流
项目使用 `sqlx-cli` 工具进行数据库迁移管理，其工作流如下：
1.  **创建迁移**: 使用 `sqlx migrate add -r <name>` 命令创建新的迁移文件（`.up.sql` 和 `.down.sql`）。
2.  **编写SQL**: 在 `.up.sql` 文件中编写应用变更的 SQL（如 `CREATE TABLE`, `INSERT`），在 `.down.sql` 文件中编写回滚的 SQL（如 `DROP TABLE`, `DELETE`）。
3.  **应用迁移**: 运行 `sqlx migrate run` 命令，将所有未应用的迁移按顺序应用到数据库。
4.  **测试集成**: 在 Rust 测试中，可以使用 `#[sqlx::test(migrations = "./migrations")]` 宏，它会自动为每个测试创建一个干净的临时数据库并应用所有迁移，确保测试的独立性和可靠性。集成测试 `admin_auth_integration.rs` 就是一个很好的例子，它验证了从创建管理员到登录、更新、删除的完整流程。

**Section sources**
- [Cargo.toml](file://backend/Cargo.toml)
- [README.md](file://backend/migrations/README.md)
- [models.rs](file://backend/src/admin/models.rs)
- [service.rs](file://backend/src/admin/service.rs)
- [admin_auth_integration.rs](file://backend/tests/admin_auth_integration.rs)

## 总结
`royale-arena` 的数据库模式设计清晰、规范。通过使用 UUID 作为主键、ENUM 约束状态、JSON 存储复杂配置以及自动管理时间戳，确保了数据的完整性、灵活性和可维护性。表间关系明确，外键约束合理。近期对游戏状态枚举的扩展（新增 'hidden' 和 'deleted' 状态）增强了游戏生命周期的管理能力，支持更复杂的业务场景。在 Rust 后端，通过集成 SQLx 库，实现了编译时的类型安全查询，极大地降低了运行时错误的风险，并通过 `sqlx-cli` 工具实现了可靠的数据库迁移管理，为项目的稳定运行奠定了坚实的基础。