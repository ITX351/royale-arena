# 技术栈

<cite>
**本文档中引用的文件**  
- [Cargo.toml](file://backend/Cargo.toml)
- [package.json](file://frontend/package.json)
- [requirements.txt](file://python_directors/requirements.txt)
- [server.py](file://python_directors/server.py)
- [main.rs](file://backend/src/main.rs)
- [routes.rs](file://backend/src/routes.rs)
- [admin/service.rs](file://backend/src/admin/service.rs)
- [admin/handlers.rs](file://backend/src/admin/handlers.rs)
- [admin/models.rs](file://backend/src/admin/models.rs)
- [auth/service.rs](file://backend/src/auth/service.rs)
- [auth/jwt.rs](file://backend/src/auth/jwt.rs)
- [database.rs](file://backend/src/database.rs)
- [config.rs](file://backend/src/config.rs)
- [errors.rs](file://backend/src/errors.rs)
- [vite.config.ts](file://frontend/vite.config.ts)
- [main.ts](file://frontend/src/main.ts)
- [App.vue](file://frontend/src/App.vue)
</cite>

## 更新摘要
**已做更改**   
- 更新了后端技术栈部分，将Rust版本从旧版本更新为1.9
- 新增了关于系统初始化时自动暂停所有游戏的功能说明
- 更新了导演系统中的手动存盘和继续游戏功能描述
- 增强了核心技术协同机制部分对状态恢复流程的解释
- 更新了相关源码文件的引用信息

## 目录
1. [前端技术栈](#前端技术栈)  
2. [后端技术栈](#后端技术栈)  
3. [导演系统中的Python Flask](#导演系统中的python-flask)  
4. [核心技术协同机制](#核心技术协同机制)  

## 前端技术栈

royale-arena项目的前端部分基于现代化的Vue生态构建，采用组件化、响应式架构，确保了开发效率与运行性能的平衡。

### Vue 3 与 TypeScript
前端框架采用 **Vue 3**（版本 `^3.5.18`），利用其组合式API（Composition API）和响应式系统，实现复杂游戏状态的高效管理。Vue 3的Proxy响应式机制相比Vue 2的Object.defineProperty提供了更好的性能和更少的限制。

类型安全由 **TypeScript**（版本 `~5.8.3`）保障，通过静态类型检查减少运行时错误，提升代码可维护性。类型定义贯穿于组件、状态和API交互中，确保数据流的清晰与安全。

### 状态管理：Pinia
状态管理采用 **Pinia**（版本 `^3.0.3`），作为Vue官方推荐的状态库，它替代了Vuex。Pinia提供更简洁的API、模块化设计和出色的TypeScript支持。在本项目中，Pinia用于集中管理：
- 用户认证状态（玩家/导演）
- 游戏全局状态（时间、安全区、玩家列表）
- 玩家个人状态（生命值、位置、道具）
- 系统公告与消息队列

其模块化store设计使得状态逻辑清晰分离，便于维护和测试。

### 构建工具：Vite
项目构建和开发服务器基于 **Vite**（版本 `^7.1.2`）。Vite利用现代浏览器的原生ES模块支持，实现了闪电般的冷启动和即时的热模块替换（HMR）。其优势包括：
- **极速启动**：无需打包，直接提供源码。
- **高效HMR**：模块更新无需全页刷新。
- **生产优化**：基于Rollup进行代码分割和压缩。

Vite的配置文件 `vite.config.ts` 集成了Vue插件，确保了对Vue单文件组件（SFC）和JSX的支持。

**中文(中文)**
- [package.json](file://frontend/package.json) - *更新了Vite和TypeScript版本*
- [vite.config.ts](file://frontend/vite.config.ts) - *Vite构建配置*
- [main.ts](file://frontend/src/main.ts) - *Vue应用初始化*
- [App.vue](file://frontend/src/App.vue) - *根组件结构*

## 后端技术栈

后端系统采用Rust语言构建，以追求极致的性能、内存安全和并发处理能力，是支撑实时游戏逻辑的核心。

### 编程语言：Rust
Rust作为系统级编程语言，以其“零成本抽象”和“内存安全”著称。根据提交记录，项目已升级至 **Rust 1.9** 版本。它通过所有权（Ownership）、借用（Borrowing）和生命周期（Lifetimes）机制，在编译期杜绝了空指针、数据竞争等常见错误，无需垃圾回收器即可保证内存安全。这使得royale-arena后端在处理高并发WebSocket连接时既高效又可靠。

### Web框架：Axum
Web服务框架采用 **Axum**（版本 `0.8.4`），它是Rust异步生态中的现代Web框架，构建于Tokio之上。Axum的核心优势包括：
- **类型安全路由**：利用Rust的类型系统，确保路由处理器的参数和返回值正确。
- **异步原生支持**：所有处理函数均为`async`，完美契合Tokio运行时。
- **中间件集成**：通过`tower-http`库，轻松集成CORS、日志追踪等中间件。
- **WebSocket支持**：直接支持WebSocket协议，用于实时通信。

Axum负责处理所有HTTP请求，包括REST API和WebSocket握手。

### 异步运行时：Tokio
**Tokio**（版本 `1.0`）是Rust事实上的异步运行时标准。它提供了一个多线程、工作窃取（work-stealing）的调度器，能够高效地处理成千上万的并发任务。在本项目中：
- 所有I/O操作（数据库查询、网络通信）都是非阻塞的。
- 每个WebSocket连接作为一个轻量级的`async`任务运行，极大提升了系统的并发能力。
- `features = ["full"]` 启用了文件系统、定时器、TCP/UDP等完整功能集。

### 数据库库：SQLx
**SQLx**（版本 `0.8.6`）是一个“运行时安全”的Rust SQL库。它与传统ORM不同，其核心特性是：
- **编译时SQL检查**：通过在编译时连接数据库，验证SQL查询的正确性，防止SQL注入。
- **无宏代码生成**：直接执行SQL，代码更直观。
- **异步支持**：与Tokio无缝集成，提供异步的数据库操作。
- **数据库支持**：通过`features = ["mysql"]`指定使用MySQL数据库。

后端使用SQLx与MySQL数据库交互，存储游戏的静态配置，如玩家账户、游戏规则等。

### 序列化库：Serde
**Serde**（版本 `1.0`）是Rust中最流行的序列化框架。它通过派生宏（`#[derive(Serialize, Deserialize)]`）为数据结构自动生成高效的序列化和反序列化代码。在本项目中：
- 用于将Rust结构体序列化为JSON，通过REST API返回给前端。
- 用于反序列化前端发送的JSON请求体。
- 与`serde_json`库配合，处理JSON格式的数据。
- 与`uuid`和`chrono`库集成，支持UUID和时间类型的序列化。

**中文(中文)**
- [Cargo.toml](file://backend/Cargo.toml) - *定义了Axum、Tokio、SQLx、Serde等核心依赖，并更新至Rust 1.9*
- [main.rs](file://backend/src/main.rs) - *应用入口，集成Tokio、Axum、Tracing*
- [routes.rs](file://backend/src/routes.rs) - *Axum路由定义，包含新增的手动存盘和继续游戏接口*
- [database.rs](file://backend/src/database.rs) - *SQLx数据库连接池创建*
- [config.rs](file://backend/src/config.rs) - *应用配置加载*
- [errors.rs](file://backend/src/errors.rs) - *统一错误处理机制*

## 导演系统中的Python Flask

项目中存在一个独立的Python子系统，即“导演系统”，用于导演的实时控制和消息广播，其核心是 **Flask** 框架。

### Flask框架角色
Flask（版本 `1.0.2`）在此系统中扮演一个轻量级的Web应用服务器角色。尽管后端主服务使用Rust，但导演系统选择Python Flask，可能出于快速开发和脚本化操作的考虑。其主要功能包括：
- **提供Web界面**：通过`render_template`渲染`login.html`、`view.html`等模板，为导演提供控制台。
- **处理表单提交**：接收导演通过表单发送的指令（如`/api/send/<key>`）。
- **实现业务逻辑**：调用`action.py`中的`act`和`act_admin`函数执行具体的游戏操作。
- **管理会话**：通过URL中的加密`key`参数（由`encrypt/decrypt`函数处理）来识别导演和玩家身份，实现无状态会话。

### 系统架构与依赖
该系统采用简单的MVC模式：
- **Model**：`data.py` 定义了游戏中的角色、地点、道具等静态数据；`message.py` 管理内存中的消息队列。
- **View**：`templates/` 目录下的HTML文件。
- **Controller**：`server.py` 中的Flask路由函数。

其依赖库包括：
- **gevent** 和 **greenlet**：提供协程支持，增强Flask的并发处理能力。
- **Jinja2**：模板引擎，用于动态生成HTML页面。

```
flowchart TD
A[导演浏览器] --> B[/api/login]
B --> C{Flask server.py}
C --> D[验证ID]
D --> E[生成加密Key]
E --> F[重定向到 /api/view/<key>]
F --> G[渲染 view_all.html]
G --> H[显示所有消息]
I[发送指令] --> J[/api/send/<key>]
J --> C
C --> K[调用 action.py]
K --> L[更新 message.py]
L --> M[重定向刷新]
```

**中文(中文)**
- [server.py](file://python_directors/server.py) - *Flask应用主逻辑，包含登录、视图、消息发送等功能*
- [requirements.txt](file://python_directors/requirements.txt) - *Python依赖列表*

## 核心技术协同机制

royale-arena项目通过分层架构，将不同技术栈的优势发挥到极致，共同支撑实时游戏、REST API和WebSocket通信。

### 分层架构设计
系统采用清晰的分层设计：
1.  **前端 (Vue 3)**：负责用户交互，通过REST API获取初始数据，通过WebSocket接收实时更新。
2.  **后端核心 (Rust + Axum + Tokio)**：处理高并发、低延迟的实时游戏逻辑，是系统的性能支柱。
3.  **导演系统 (Python + Flask)**：作为独立的控制面板，提供导演专用的Web界面和操作入口。
4.  **数据库 (MySQL)**：持久化存储静态配置，由Rust后端通过SQLx访问。

### 实时游戏与通信
实时性是游戏的核心。系统通过以下方式实现：
- **REST API (Axum)**：处理非实时的、幂等的请求，如用户登录、获取游戏列表。这些请求是“拉取”模式。
- **WebSocket (Axum)**：处理实时的、双向的通信。当玩家发送行动指令或导演进行操作时，这些事件通过WebSocket流实时广播给所有相关客户端，实现“推送”模式。Rust的Tokio运行时确保了WebSocket连接的高并发和低延迟。
- **内存状态管理**：根据`backend\QWEN.md`，游戏的实时状态（如玩家位置、生命值）存储在内存中，而非频繁读写数据库，这极大地提升了响应速度。行动结束后，状态才可能持久化。

### 技术协同流程
一个典型的玩家行动流程如下：
1.  玩家在Vue前端点击“移动”按钮。
2.  前端通过WebSocket连接，向Rust后端发送“移动”指令。
3.  Rust后端在Tokio运行时中处理该异步任务，验证指令，更新内存中的玩家状态。
4.  后端通过广播，将状态更新通过WebSocket推送给所有客户端（包括导演系统）。
5.  导演在Flask控制台中看到实时更新，并可通过其界面发送全局指令。
6.  导演的指令同样被Rust后端接收并处理，影响游戏状态。

此外，系统引入了新的状态管理功能：
- **启动时自动暂停**：根据`system_initializer.rs`，服务器启动时会自动将所有“进行中”的游戏状态变更为“暂停中”，确保状态可以正确恢复。
- **手动保存与继续**：导演可以通过`manual_save`接口手动保存当前游戏状态到磁盘，后续可通过`resume_game`接口选择特定存档文件继续游戏。

这种架构将高并发、低延迟的实时处理交给Rust，将快速迭代的Web界面交给Python Flask，而将用户友好的交互体验交给Vue 3，实现了各技术栈的最佳协同。

**中文(中文)**
- [backend\QWEN.md](file://backend\QWEN.md)
- [frontend\QWEN.md](file://frontend\QWEN.md)