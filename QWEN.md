# Royale Arena 项目总览

## 项目简介

Royale Arena是一个基于网页的大逃杀游戏，玩家可以在特定时间段内执行行动，包括移动、搜索、攻击和使用道具等操作。游戏采用现代化的前后端分离架构，为玩家和导演提供流畅的交互体验。

## 技术架构

### 整体架构
- 前端：Vue3 + TypeScript + Vite，采用客户端渲染(CSR)部署到Nginx服务器
- 后端：Rust语言开发，提供REST API和WebSocket接口
- 数据存储：
  - 静态数据（玩家信息等）存储在MySQL数据库
  - 动态游戏数据仅在内存中处理，行动结束后保存到本地文件

### 核心组件
1. 前端应用：玩家交互界面和导演控制台
2. 后端服务：API服务器和WebSocket服务器
3. 数据存储：MySQL数据库和本地文件存储

## 核心功能

### 玩家功能
- 登录游戏并进入交互界面
- 在限定时间内执行行动（移动、搜索、攻击、使用道具）
- 查看游戏状态和公告信息

### 导演功能
- 创建和管理游戏
- 设置游戏规则和参数
- 控制游戏进程（开始/结束行动时间、缩圈、空投等）
- 监控玩家状态和游戏进展

### 系统管理功能
- 管理员创建游戏并分配管理密码
- 导演使用管理密码进入控制台
- 演员使用分配的密码登录游戏

## 游戏规则概览

- 游戏流程：白天投票，晚上行动
- 地图：约50个不同地点
- 玩家数量：最多100人
- 生命值和体力值系统
- 道具搜索和合成系统
- 安全区逐步缩小机制
- 实时行动和投票机制

## 开发约束

1. 不使用游戏引擎或第三方实时通信服务
2. 不使用ORM框架操作MySQL
3. WebSocket仅处理实时操作指令
4. REST API处理认证和状态查询
5. 游戏过程中不访问数据库

## 文档结构

- QWEN.md（项目总览、前端上下文、后端上下文）
- PRD.md（前端需求、后端需求）
- docs/api-spec.md（API规范）
- docs/game-rules.md（游戏规则）

## 开发要求

- 开发环境在Windows下，不尝试执行任何只可以在Linux执行的命令行。所有指令均使用Windows终端允许执行的命令。
- 不需要尝试新建文件夹，可以通过直接创建指定的新文件的方式自动创建新文件夹。
- 不执行`docker compose up`或`cargo run`等命令，因为这些命令会阻塞CLI终端导致后续操作无法正确运行。需要执行测试时由用户进行配合。
- CLI所有交互使用简体中文。
- 推进开发时，读取任务列表`task-list.md`，根据任务列表完成适量的开发内容。完成一部分开发后，自动更新任务列表的状态进行相关标注。
- 最大限度保证代码的复用和可读性，避免重复复制粘贴大量代码。

## 代码规范

### 命名约定
- 模块名：使用蛇形命名法（snake_case），如`game_service`
- 结构体名：使用驼峰命名法（CamelCase），如`AdminUser`
- 函数名：使用蛇形命名法（snake_case），如`get_games`
- 常量名：使用大写蛇形命名法（UPPER_SNAKE_CASE），如`MAX_PLAYERS`
- 变量名：使用蛇形命名法（snake_case），如`player_count`

### 代码组织
- 每个模块应有清晰的职责划分
- 相关功能应组织在同一模块内
- 避免过大的文件，适时拆分代码到子模块
- 使用模块系统合理组织代码结构

### 错误处理
- 使用语言特定的错误处理机制（如Rust的`Result`类型）
- 对于Web请求，返回适当的HTTP状态码
- 自定义错误类型应实现标准错误trait

### 注释和文档
- 公共API应有文档注释
- 复杂逻辑应有行内注释说明
- 模块级别应有注释说明其功能和用途

### 依赖管理
- 明确声明所有依赖项及其版本
- 避免不必要的依赖
- 定期更新依赖项以获取安全补丁

### 性能考虑
- 避免不必要的克隆操作
- 合理使用引用和生命周期（Rust特定）
- 对于热点代码路径，考虑性能优化

### 测试编写要求
- 避免代码重复：测试代码应遵循DRY原则，对于公用的功能应定义公用函数供各个测试模块调用
- 模块化测试：对于有代码复用需求的测试模块，应定义相关的辅助函数避免大量代码的复制粘贴